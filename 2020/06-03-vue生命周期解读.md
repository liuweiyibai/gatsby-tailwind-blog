---
title: 解读 vue 生命周期
tags:
  - vue
category:
  - 编程笔记
slug: interpret-the-vue-lifecycle
thumbnail: '../../thumbnails/vue.png'
date: 2020-06-03 09:09:11
---

对于 vue 来说它的生命周期就是 vue 实例从创建到销毁的过程

## 生命周期函数

在生命周期的过程中运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力

<!-- <https://juejin.im/post/6844903879100858382#heading-19> -->

![生命周期总结图](https://cdn.clearlywind.com/blog-images/images/vue-life-cycle.png)

## 钩子函数

`vue` 的完整生命周期可分为三个阶段：

- 初始化阶段
- 运行阶段
- 销毁阶段

所以共存在很多钩子函数，他们在 `vue` 生命周期不同的阶段进行操作，下面介绍生命周期执行顺序，以及对应的周期适合做的操作，生命周期如下：

- `beforeCreate`

  通过 `new Vue()` 创建 `vue` 实例， `vue` 的生命周期便拉开了序幕，首先会执行 `beforeCreate` 钩子函数。此时的 `vue` 实例只是一个空壳，还未挂载 `dom` 元素，无法访问到数据和真实的 `dom` ，一般不做操作

  总结：

  - 实例初始化，可以访问 `this`
  - `$data`，`data observer` 和 `event/watcher` 事件配置没有完成，无法访问 `data` 中的数据， `methods` 中的方法还无法调用， `event` 事件无法使用
  - `$el` 还没有初始化， `dom` 没有挂载，无法访问

- `created`

  这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发 `updated` 函数和不会触发其他钩子函数，一般可以在这里做初始数据的获取

  - 实例创建完成，可以访问 `this`
  - `$data` 初始化，实例已完成以下的配置：`数据观测 data observer`、`属性` 、方法的运算 、`watch/event 事件回调`，此时可以访问 `data` 中的数据，可以调用 `methods` 中的方法
  - `$el` 还没有初始化， `dom` 没有挂载，无法访问

- `beforeMount`

  在这个函数中虚拟 `dom` 已经创建完成（马上就要渲染），这里也可以更改数据，不会触发 `updated` ，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数

- `mounted`

  在这个函数调用时，组件已经出现在页面中，数据、真实 `dom` 都已经处理好了，事件都已经挂载好了，可以在这里操作真实 `dom` 等事情

  `$el` 挂载，可以访问和操作 dom

  > 注意: `mounted` 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 `vm.$nextTick`

- `beforeUpdate`

  当组件或实例的数据更改之后，会立即执行 `beforeUpdate` ，然后 `vue` 的虚拟 `dom` 机制会重新构建虚拟 `dom` 与上一次的虚拟 `dom` 树利用 `diff` 算法进行对比之后重新渲染

- `updated`

  当更新完成后，执行 `updated` ，数据已经更改完成， `dom` 也重新 `render` 完成，可以操作更新后的虚拟 `dom`

- `beforeDestroy`

  当通过某种方式调用 `$destroy` 方法后，立即执行 `beforeDestroy` 函数做一些善后工作，如清除计时器、清除非指令绑定的事件等

- `destroyed`

  组件的数据绑定、监听等去掉后只剩下 `dom` 空壳，此时执行 `destroyed` 。当然，也可以在这里完成上述操作

在被 `keep-alive` 包含的`组件/路由`中，会多出两个生命周期的钩子： `activated` 与 `deactivated`

## 总结

### 在页面首次加载执行顺序

- `beforeCreate`

  在实例初始化之后、创建之前执行

- `created`

  实例创建后执行

- `beforeMounted`

  在挂载开始之前调用

- `filters`

  挂载前加载过滤器

- `computed`

  计算属性

- `directives-bind`

  只调用一次，在指令第一次绑定到元素时调用

- `directives-inserted`

  被绑定元素插入父节点时调用

- `activated`

  `keek-alive` 组件被激活时调用，则在 `keep-alive` 包裹的嵌套的子组件中触发

- `mounted`

  挂载完成后调用

- `{{}}`
  `mustache` 表达式渲染页面

### 页面 dom 发生变化时

修改页面 dom 时，被自动调用的选项顺序如下：

- `watch`

  首先先监听到了改变事件

- `filters`

  过滤器没有添加在该 `input` 元素上，但是也被调用了

- `beforeUpdate`

  数据更新时调用，发生在虚拟 `dom` 打补丁前

- `directived-update`

  指令所在的组件的 `vNode` 更新时调用，但可能发生在其子 `vNode` 更新前

- `directives-componentUpdated`

  指令所在的组件的 `vNode` 及其子组件的 `vNode` 全部更新后调用

- `updated`

  组件 `dom` 已经更新

### 组件销毁时，执行顺序如下

- `beforeDestroy`

  实例销毁之前调用

- `directives-unbind`

  指令与元素解绑时调用，只调用一次

- `deactivated`

  `keep-alive` 组件停用时调用

- `destroyed`

  实例销毁之后调用

## 路由钩子

包括全局路由钩子和函数内的路由钩子

路由钩子的错误捕获

```js
router.onError(callback => {
  // 2.4.0新增 并不常用，了解一下就可以了
  console.log(callback, 'callback')
})
```

- `beforeRouteEnter`

  进入路由前，在路由独享守卫后调用。 不能获取组件实例 `this`，组件实例还没被创建，
  如何在改钩子中访问 `this`

  ```js
  beforeRouteEnter (to, from, next) {
    console.log('在路由独享守卫后调用');
    next(vm => {
      // 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面，
    })
  }
  ```

- `beforeRouteUpdate`

  (v2.2 新增)
  路由复用同一个组件时，在当前路由改变，但是该组件被复用时调用，可以访问组件实例 `this`
  举例来说，对于一个带有动态参数的路径 `/foo/:id`，在 `/foo/1` 和 `/foo/2` 之间跳转的时候，
  由于会渲染同样的 `Foo` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。

- `beforeRouteLeave`

  离开当前路由时，导航离开该组件的对应路由时调用，可以访问组件实例 `this`

## 触发钩子的完整顺序

将`路由导航`、`keep-alive`、和`组件生命周期钩子`结合起来的，触发顺序，假设是从 a 组件离开，第一次进入 b 组件：

- `beforeRouteLeave`：路由组件的组件离开路由前钩子，可取消路由离开
- `beforeEach` ： 路由全局前置守卫，可用于登录验证、全局路由 `loading` 等
- `beforeEnter` ： 路由独享守卫
- `beforeRouteEnter` ：路由组件的组件进入路由前钩子
- `beforeResolve` ：路由全局解析守卫
- `afterEach` ：路由全局后置钩子
- `beforeCreate` ：组件生命周期，不能访问 `this`
- `created` ：组件生命周期，可以访问 `this` ，不能访问 `dom`
- `beforeMount` ：组件生命周期
- `deactivated` ： 离开缓存组件 `a`，或者触发 `a` 的 `beforeDestroy` 和 `destroyed` 组件销毁钩子
- `mounted` ：访问/操作 `dom`
- `activated` ：进入缓存组件，进入 `a` 的嵌套子组件(如果有的话)
- 执行 `beforeRouteEnter` 回调函数 `next`
