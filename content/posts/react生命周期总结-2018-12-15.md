---
title: react 生命周期总结
tags:
  - react
category:
  - 编程笔记
slug: react-life-cycle-summary
date: 2018-12-15 14:18:16
thumbnail: '../thumbnails/react.png'
---

`react` 生命周期总结

![react 生命周期](https://cdn.clearlywind.com/blog-images/images/react-life-cycle.png)

`v16.0` 前的周期

1. 组件挂载阶段:

   - `getDefaultProps`

   - `getInitialState`

   - `componentWillMount`

   `componentWillMount` 只在初始化时候被调用一次，可以使用 `setState` 方法，会立即更新 `state`，然后接着进行`render`。`componentWillMount`方法的调用在`constructor`之后，在`render`之前，在这方法里的代码调用`setState`方法不会触发重渲染，所以它一般不会用来作加载数据之用，它也很少被使用到。

   - `render`

     创建虚拟 `DOM` ，进行 `diff` 算法，更新 `DOM` 树都在此进行。

     > 注意：在 `render` 中千万不可使用 `setState` 方法，不然马上会引起无限的报错了。如果其中包含其他的子组件，那么子组件的生命周期才开始进行

   - `componentDidMount`

     组件渲染完成，只执行一次。在子组件都加载完毕后执行， `DOM` 渲染完成，此时就可以操作 `DOM` 了。一般从后台获取的数据，都会与组件上要用的数据有关，所以都在 `componentDidMount` 方法里面操作。虽然与组件上的数据无关的加载，也可以在 `constructor` 里操作，但 `constructor` 执行的是组件 `state` 初绐化工作，并不是设计来作加载数据这工作的，所以所有有副作用的代码都会集中在 `componentDidMount` 方法里

2. 组件更新阶段:

   - `componentWillReceiveProps(nextProps)`

     在接收到新的 `prop` 时被调用，这个方法在初始化 **`render` 时不会被调用**

     在`componentWillReceiveProps` 中调用 `this.setState()` 将不会引起第二次渲染

   - `shouldComponentUpdate(nextStates)`

     返回一个布尔值。在组件接收到新的 `props` 或者 `state` 时被调用。在初始化时或者使用 `forceUpdate` 时不被调用

     在 `setState` 的时候，就得要判断 `nextProps.xxx !== this.props.xxx || nextState.xxx !== this.state.xxx`

     通过返回 `true` 或者 `false` 来确定是不是把改变的值放到 `render` 里渲染。以此可用来减少组件的不必要渲染，优化组件性能

   - `componentWillUpdate(nextProps, nextState)`

     在组件接收到新的 `props` 或者 `state` 但是还没有 `render` 时被调用，在初始化时不会被调用。
     在这里可以执行一些组件更新发生前的工作

   - `componentDidUpdate(nextProps, nextState)`

     在组件完成更新后立即调用。可以操作组件更新的 `DOM` ，在初始化时不会被调用。`prevProps` 和 `prevState` 这两个参数指的是组件更新前的 `props` 和 `state`

3. 组件卸载阶段

   - `componentWillUnmount`

     此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清除组件中使用的定时器，清除 `componentDidMount` 中手动创建的 `DOM` 元素等，以避免引起内存泄漏

v16.4 的生命周期

- `getDerivedStateFromProps`

  可以说，这个生命周期的功能实际上就是将传入的 `props` 映射到 `state` 上面

  由于 16.4 的修改，这个函数会在每次 `re-rendering` （重新渲染）之前被调用，即使你的 `props` 没有任何变化，而是父 `state` 发生了变化，父组件发生了 `setState` 操作导致子组件发生了 `re-render` ，这个生命周期函数依然会被调用。看似一个非常小的修改，却可能会导致很多隐含的问题。

  这个生命周期函数是为了替代 `componentWillReceiveProps` 存在的，所以在你需要使用 `componentWillReceiveProps` 的时候，就可以考虑使用 `getDerivedStateFromProps` 来进行替代了

  两者的参数是不相同的， `getDerivedStateFromProps` 是一个静态函数，也就是这个函数不能通过 `this` 访问到 `class` 的属性，也并不推荐直接访问属性。而是应该通过参数提供的 `nextProps` 以及 `prevState` 来进行判断，根据新传入的 `props` 来映射到 `state`

  需要注意的是，如果 `props` 传入的内容不需要影响到你的 `state` ，那么就需要返回一个 `null` ，这个返回值是必须的，所以尽量将其写到函数的末尾

  ```js
  static getDerivedStateFromProps(nextProps, prevState) {
    const { type }  = nextProps;
    // 当传入的 type 发生变化的时候，更新 state
    if (type !== prevState.type) {
      return {
        type,
      };
    }
    // 否则，对于 state 不进行任何操作
    return null;
  }
  ```

## 总结

### props 发生改变时会触发

- `componentWillReceiveProps(nextProps)`

- `shouldComponentUpdate(nextProps, nextState)`

- `componentWillUpdate(nextProps, nextState)`

- `render()`

- `componentDidUpdate(prevProps, prevState)`

### state 发生改变时候更新

- `shouldComponentUpdate(nextProps, nextState)`

- `componentWillUpdate(nextProps, nextState)`

- `render()`

- `componentDidUpdate(prevProps, prevState)`

### 组件销毁

- `componentWillUnmount()`

### 使用 redux 时候情况

在使用 `redux` 做状态管理时候，基本不需要透过生命周期去做 `setState` 这样的状态管理了，基本都是用 `props` 来传递来重新渲染，需要注意的仅仅是在哪个生命周期时候触发 `action` ，比如需要进行 `ajax` 请求时候一般都是在 `componentDidMount` 和 `componentWillReceiveProps` 时候进行，在 `reducer` 中处理完，然后在通过 `props` 传入组件执行组件的更新周期
