---
title: js 执行上下文
---

## js 执行机制

整个 js 的执行机制包括：执行上下文和调用栈、垃圾回收机制。

### 执行上下文与调用栈

执行上下文：即代码的执行环境，它包括：

1. 全局上下文
2. 函数上下文
3. Eval 执行上下文(知道就好)

let name='gxb'
function demo(){}
复制代码
从这样一段简单的 js 代码说起
这段代码执行时，肯定是先创建一个全局的执行上下文
这个全局的执行上下文中，全局对象、this 是必须的。并且这个 this 的指向就是全局对象

值得注意的是：此时的 name 变量里面放的是 undefind
为啥呢？
因为每一个执行上下文均有两个阶段：创建阶段和执行阶段
在创建阶段所做的事如下：

创建全局对象
创建 this，并使它指向全局
给变量和函数安排储存空间
默认给变量赋值为 undefined；将函数声明放入内存
创建作用域链

值的赋予在执行阶段（你现在理解变量提升的原理了吗）
函数执行上下文和全局执行上下文基本一致，不同之处如下

首先创建的时机上
再者创建的频率上，全局上下文只会被创建一次
最后内容上，全局上下文开始里面是全局对象和 this 并且 this 指向全局对象；而函数上下文中创建的是参数对象 arguments，this 也得在运行时才能确定了

### 调用栈

那么调用栈又是干啥的呢？
在 js 运行时，一个函数从堆内存拿出来，整成了函数上下文的模样。这个函数上下文放在哪呢？这确实是个问题吧
因为我们知道一个函数执行完毕后，它里面数据所占的那些地址是要被释放了的，并且有时候函数里面是要又套函数的它们之间的执行顺序已经内存释放顺序也是需要考虑的。
故想到可以采用一个栈的数据结构，来放置这些函数上下文，这就是调用栈
递归问题和闭包问题这里面（执行上下文、调用栈、作用域）可以得到充分的理解
