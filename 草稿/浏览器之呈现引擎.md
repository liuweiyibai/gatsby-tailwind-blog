# 呈现引擎

负责显示请求的内容，为给定的 URL 提供可视化的展示。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS；以及 JavaScript、XML 内容，并将解析后的内容显示在屏幕上。并且 User Interface 中展示的 Layout。其中关键的组件是 HTML 解析器，它可以让 Rendering Engine 展示差乱的 HTML 页面。 值得注意：不同的浏览器使用不同的 Rendering Engine。例如 IE 使用 Trident，Firefox 使用 Gecko，Safai 使用 Webkit。Chrome 和 Opera 使用 Webkit（以前是 Blink）

常见的呈现引擎就是我们所说的浏览器引擎（内核），Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。

WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，可以查看 [Webkit 官网](https://webkit.org)。

呈现引擎的工作流程:

![呈现引擎的基本流程](呈现引擎的基本流程.png)

1. HTML Parser 解析 HTML 文档，将元素转换为由 DOM 节点组成的树结构，称之为**内容树 - Content Tree**
2. 同时 CSS Parser 解析 Style 数据，包括外部的 CSS 文件以及在 HTML 元素中的样式为 CSSOM 树，结合 1 中的**内容树**用于创建另一棵树 **呈现树 - Render Tree**，呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。
3. Layout 过程。呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。
4. Painting 过程，呈现引擎会遍历 **呈现树 - Render Tree**，由用户界面后端层将每个节点绘制出来。调用 UI Backend 提供的接口绘制每个节点。

> 这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

#### 各呈现引擎主流程示例

![WebKit主流程](https://clearlywind.oss-cn-beijing.aliyuncs.com/blog-images/images/WebKit主流程.png)

![Gecko主流程](https://clearlywind.oss-cn-beijing.aliyuncs.com/blog-images/images/Gecko主流程.jpg)

我们以 Chrome 为例，来简单总结一下，为构建渲染树，浏览器大体上完成了下列工作:

1. 从 DOM 树的根节点开始遍历每个可见节点。

   - 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
   - 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点---不会出现在渲染树中，---因为有一个显式规则在该节点上设置了“display: none”属性。

2. 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
3. 发射可见节点，连同其内容和计算的样式。

最终输出的渲染同时包含了屏幕上的所有可见内容及其样式信息。有了渲染树，**我们就可以进入“布局”阶段**。

#### Layout 过程 和 Painting 过程

呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。

HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中**靠后位置元素通常不会影响靠前位置元素的几何特征**，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历。

https://cloud.tencent.com/developer/article/1715276

https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn
